import * as NodeRsa from "node-rsa";
import { ActiveLogger } from "@activeledger/activelogger";
import { Hash } from "./hash";
import { AsnParser } from "./asn";
export class KeyPair {
    constructor(type = "rsa", key) {
        this.type = type;
        switch (type) {
            case "rsa":
                if (key)
                    this.rsa = new NodeRsa(key);
                break;
            case "bitcoin":
            case "ethereum":
            case "secp256k1":
                this.curve = new (require("elliptic")).ec("secp256k1");
                if (key) {
                    if (key.indexOf("PRIVATE-") !== -1 || key.indexOf("PUBLIC-") !== -1) {
                        let isPriv = false;
                        if (key.indexOf("PRIVATE") !== -1) {
                            isPriv = true;
                        }
                        key = key.replace(/-*[A-Z ]*-|\n/g, "");
                        key = Buffer.from(key, "base64").toString();
                        if (!isPriv) {
                            this.key = this.curve.keyFromPublic(key, "hex");
                        }
                        else {
                            this.key = this.curve.keyFromPrivate(key, "hex");
                        }
                    }
                    else {
                        if (key.indexOf("PRIVATE") == -1) {
                            this.key = this.curve.keyFromPublic(AsnParser.decodeECPublicKey(key), "hex");
                        }
                        else {
                            this.key = this.curve.keyFromPrivate(AsnParser.decodeECPrivateKey(key), "hex");
                        }
                    }
                }
                break;
            default:
                throw "Unknown / unset key type";
        }
    }
    generate(bits = 2048) {
        let handler;
        switch (this.type) {
            case "rsa":
                this.rsa = new NodeRsa({ b: bits });
                handler = {
                    pub: {
                        pkcs8pem: this.rsa.exportKey("pkcs8-public-pem").toString(),
                        hash: ""
                    },
                    prv: {
                        pkcs8pem: this.rsa.exportKey("pkcs8-private-pem").toString(),
                        hash: ""
                    }
                };
                handler.pub.hash = Hash.getHash(handler.pub.pkcs8pem);
                handler.prv.hash = Hash.getHash(handler.prv.pkcs8pem);
                return handler;
            case "bitcoin":
            case "ethereum":
            case "secp256k1":
                this.key = this.curve.genKeyPair();
                handler = {
                    pub: {
                        pkcs8pem: AsnParser.encodeECPublicKey(this.key.getPublic("hex")),
                        hash: ""
                    },
                    prv: {
                        pkcs8pem: AsnParser.encodeECPrivateKey(this.key.getPrivate("hex")),
                        hash: ""
                    }
                };
                handler.pub.hash = Hash.getHash(handler.pub.pkcs8pem);
                handler.prv.hash = Hash.getHash(handler.prv.pkcs8pem);
                return handler;
            default:
                throw ActiveLogger.fatal(`Cannot generate ${this.type} key pair type`);
        }
    }
    encrypt(data, encoding = "base64") {
        if (this.type == "rsa" && this.rsa) {
            return this.rsa.encrypt(data, encoding).toString();
        }
        throw ActiveLogger.fatal(data, `Cannot encrypt with ${this.type}`);
    }
    decrypt(data, encoding = "base64") {
        if (this.type == "rsa" && this.rsa) {
            return this.rsa.decrypt(data, encoding).toString();
        }
        throw ActiveLogger.fatal(data, `Cannot decrypt with ${this.type}`);
    }
    sign(data, encoding = "base64") {
        switch (this.type) {
            case "rsa":
                if (this.rsa && this.rsa.isPrivate()) {
                    return this.rsa.sign(data, encoding).toString();
                }
                throw ActiveLogger.fatal(data, `Failed to sign`);
            case "bitcoin":
            case "ethereum":
            case "secp256k1":
                if (this.key.priv) {
                    if (typeof data !== "string")
                        data = JSON.stringify(data);
                    data = Hash.getHash(data);
                    return new Buffer(this.key.sign(data).toDER()).toString("base64");
                }
                throw ActiveLogger.fatal(data, `Failed to sign`);
            default:
                throw ActiveLogger.fatal(data, `Cannot sign with ${this.type}`);
        }
    }
    verify(data, signature, encoding = "base64") {
        switch (this.type) {
            case "rsa":
                if (this.rsa)
                    return this.rsa.verify(data, signature, "utf8", encoding);
                throw ActiveLogger.fatal(data, `Failed to verify with RSA`);
            case "bitcoin":
            case "ethereum":
            case "secp256k1":
                if (typeof data !== "string")
                    data = JSON.stringify(data);
                data = Hash.getHash(data);
                return this.curve.verify(data, Buffer.from(signature, "base64").toString("hex"), this.key.getPublic());
            default:
                throw ActiveLogger.fatal(data, `Cannot verify with ${this.type}`);
        }
    }
}
//# sourceMappingURL=keypair.js.map